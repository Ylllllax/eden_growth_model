import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import time
import datetime
from EdenABCStripGeo import *   #import required classes
from BallisticStripGeo import *


class DataAnalysis:
    """class used to analyse data generated by the Ballistic Deposition Class"""
    
    def __init__(self):
        analysis_array1=np.array([])
        analysis_array2=np.array([])
        analysis_array3=np.array([])
        analysis_array4=np.array([])
        self.analysis_array1=analysis_array1
        self.analysis_array2=analysis_array2
        self.analysis_array3=analysis_array3
        self.analysis_array4=analysis_array4
        
    def add_data(self, data, target_array):
        """filling data into separate roughness array and creating the matching time array; need to enter numpy array as the parameter"""
        for i in np.arange(0, data.size):
            target_array=np.append(target_array, data[i])
        return target_array
        
    def standard_deviations(self, errors_array):
        """works out the standard deviations for each set of data values stored in a 2D array"""
        x=np.array([])
        for i in np.arange(0, len(errors_array),1):
            x=np.append(x, np.std(errors_array[i]))
        return x
                  
    def roughness_dynamics(self, other, tracker, initial_power, data_points):#generates a series of roughness values for a series of matrices
        """iterates the BD forward in time, depositing n particles for each of the iterations; takes instance of the BallisticDeposition class"""
        
        x=np.array([])
       
        m=initial_power+1
        while m<=data_points+initial_power:            
            other.deposit_particles(2**m)        
            tracker.update(data_point_number=m-initial_power) 
            x=np.append(x, other.roughness()) #appending the roughnesses of system after each set of 2**m particles have been deposited
            tracker.display(other)
            m = m+1
            
        
        
        return x

    def create_time_array(self, initial_power, data_points):
        """creating the number of data points required; equally spaced on a log-log plot"""
        t=np.array([])
        m=initial_power+1
        y=0
        while m<=data_points+initial_power:           
            y=y+2**m
            t=np.append(t, y)
            m = m+1
        return t
        
        
    def roughness_dynamics_average(self, other, tracker, initial_power, data_points, simulations):
        """repeats same dynamic process for same system size for a specified number of times"""
        ###########NEED TO ADJUST CODE HERE TO EXTRACT DATA FOR ERROR BARS#############################~~~~~~~~~~~~~~~~~~
        x=np.zeros((data_points))
        z=np.zeros((data_points,simulations))
        
        for i in np.arange(0,simulations, 1):
            tracker.update(simulation_number=i+1)
            other.reset_system(other.system_size())
            y=self.roughness_dynamics(other, tracker, initial_power, data_points)
            x=x+y
            for j in np.arange(0,data_points,1):
                z[j][i]=y[j]
        
        x=x/simulations 
        t=self.create_time_array(initial_power, data_points)
        z=self.standard_deviations(z)
        upper_error= x+z
        lower_error= x-z
        return x, t, upper_error, lower_error
################################################################################################################################

    def log_log_origin(self, other, initial_power, data_points, simulations, system_sizes):
        start = np.datetime64(datetime.datetime.now())
        #other=BallisticDeposition(L_min)
        #other=EdenCsystem(L_min)
        tracker=IterationTracker(number_of_system_sizes=system_sizes, total_data_points=data_points, total_simulations=simulations)        
        m=0
        while m<system_sizes:
            x, t, upper_error, lower_error= self.roughness_dynamics_average(other, tracker, initial_power, data_points, simulations)
            log_t=np.log(t)
            log_w=np.log(x)
            log_upper=np.log(upper_error) - log_w 
            log_lower=log_w - np.log(lower_error)
            print log_w, log_upper, log_lower
            np.savetxt('%g.txt' % other.system_size(), np.transpose([log_t, log_w, log_upper, log_lower]))
            m=m+1
            other.reset_system(other.system_size()+m*500) #increasing system by 500 each time
        end = np.datetime64(datetime.datetime.now())
        
        print start, end

############### DO NOT NEED BELOW METHOD AS ALL DATA NOW ANALYSED IN ORIGIN################################
  
    def log_log_line_plot(self, other, x_array, y_array, line_of_best_fit=None):
        """plots the roughness array against the time array stored using add_data()"""

        log_t=np.log(x_array)
        log_w=np.log(y_array)
        m, b = np.polyfit(log_t, log_w, 1)
        
        fig = plt.figure()
        fig.suptitle('Log-log Plot of Roughness Against Time', fontsize=14, fontweight='bold')
        ax = fig.add_subplot(111)
        #ax.set_title('axes title')

        ax.set_xlabel('log(t)')
        ax.set_ylabel('log(w)')
        ax.plot(log_t, log_w, 'r+')
        if line_of_best_fit == True:
            
            ax.plot(log_t, m*log_t + b, '-')
            ax.text(0.1,0.9, r'$\beta=$%g' % (m) , style='italic', horizontalalignment='left',verticalalignment='top', transform=ax.transAxes ) 
        ax.text(0.1,0.85, 'Particles Deposited=%g'  % (other.number_of_deposited_particles())  , style='italic', horizontalalignment='left',verticalalignment='top', transform=ax.transAxes ) #position of test and the test itself
        ax.text(0.1,0.8, 'System Size=%g'  % (other.system_size())  , style='italic', horizontalalignment='left',verticalalignment='top', transform=ax.transAxes )
        #plt.axis([40, 160, 0, 0.03])
        plt.grid(True)
        plt.show()
        
        return None
####################################################################################################################                
    
class IterationTracker:
    """class to track all the relevant stats during the simulation process"""

    def __init__(self, number_of_system_sizes=None, total_data_points=None, total_simulations=None):        
         self.__number_of_system_sizes=number_of_system_sizes
         self.__total_data_points=total_data_points
         self.__total_simulations=total_simulations
         self.__data_point_number=0
         self.__simulation_number=0
         
    def update(self, data_point_number=None, simulation_number=None):
        if data_point_number!=None:
            self.__data_point_number=data_point_number
        if simulation_number!=None:
            self.__simulation_number=simulation_number 
        
    def display(self, other):        
        print "%s %g, %s %g %s %g, %s %g %s %g" % ("system size =", other.system_size(), "simulation number", self.__simulation_number, "out of", self.__total_simulations, "data point",self.__data_point_number, "out of", self.__total_data_points )      
         
        
    