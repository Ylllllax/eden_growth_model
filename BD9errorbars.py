import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import time
import datetime

class BallisticDeposition:
    
    def __init__(self, L_x):
        
        """need to enter parameters as floats; actual system width is L_x-2 as edge columns are not used;
        Insert True if you want to impose periodic boundary conditions"""
        self.__xsize = L_x
     
        m = 0
        n = 0
        self.__total_particles=m #keeps track of how many times the instance has been propagated       
        if isinstance(L_x, int) == True:
            system_array = np.zeros((1, self.__xsize)) #indices go from 0 to self.__xsize-1
            self.__system_array = system_array 
        else:
            raise Exception("need to insert an integer")
            
        
    def __repr__(self):
        return "%s(number of columns = %g)" % ("system size", self.__xsize)
        
    
    def __str__(self):
        return "[%s]" % (self.__xsize)
        
    def number_of_deposited_particles(self):
        return self.__total_particles
        
    def set_number_of_particles(self, n):
        self.__total_particles=n 
        return self.__total_particles
    
    def size_of_system(self):
        return self.__xsize
    
    def current_array(self):
        """returns current heights"""
        return self.__system_array
        
    def random_columns(self, n): #where n is the number of iterations; function generates random column numbers
        #ONLY METHOD THAT CHANGES WHEN IMPOSING PERIODIC BOUNDARY CONDITIONS
        self.chosen_columns=np.random.random_integers(0,self.__xsize-1, n) #inclusive of upper and lower bounds
        return self.chosen_columns 
    
    def array_search(self, j):
        """returns the height for a particular column"""
        return self.__system_array[0][j]
    
            
    def update_array(self, h, j): #turns a site from 0 to 1 in a matrix
        """changes the height to h for element j in the heights array"""
        self.__system_array.itemset((0,j),h)
        return self.__system_array
 
    def deposit_particles(self, n):#here n is for the number of particles we are depositing on the lattice
        """deposit n particles"""
        self.set_number_of_particles(self.number_of_deposited_particles()+n)
        self.random_columns(n) #every time is called get a DIFFERENT set of random numbers
        for j in self.chosen_columns:#if statements applying boundary conditions
            #also will work when BCs not imposed if edge columns are NEVER selected, i.e. system is effectively two columns smaller
            if j==0:
                p=self.array_search(0)+1 
                q=self.array_search(1)
                r=self.array_search(self.__xsize-1)
                
            if j==self.__xsize-1:
                p=self.array_search(self.__xsize-1)+1 
                q=self.array_search(0)
                r=self.array_search(self.__xsize-2)               
                
            else:
                p=self.array_search(j)+1 
                q=self.array_search(j+1)
                r=self.array_search(j-1)
            
            x=[p,q,r]
            h=max(x)            
            self.update_array(h, j)
        return h
        
        
    def roughness(self): #works out the roughness for a particular square matrix
        """returns the rougheness for the current heights array"""
        x=np.array([])
        
        for j in np.arange(0, self.__xsize,1):
            x=np.append(x, self.array_search(j))
            
           
        y=np.average(x)
        a=(x-y)**2  
        b=np.sum(a)
        z=(1/(float(self.__xsize)))*b #remember edge columns are kept empty so column does not
        w=z**0.5
        return w
        
    #def correlation(self):# needs working on
    #    """computes the correlation length (incomplete method)"""
    #    
    #    x=np.average(self.system_array)
    #    y=np.array([])
    #    
    #    for i in np.arange(0, self.__xsize): 
    #        for j in np.arange(0, self.__xsize):
    #        
    #            y=np.append(y, self.system_array[0][i]*self.system_array[0][j])
    #    print y.size
    #    z=(np.sum(y))/(float(self.__xsize)**2)
    #    self.correlation_length = z - x**2
    #    
    #    return self.correlation_length
               
            
    def reset_system(self, system_size=None):
        """resets system back to initial conditions with column heights of 0; the initially defined parameters remain unchanged"""
        self.__total_particles=0
        if system_size != None:
            self.__xsize = system_size
        self.__system_array= np.zeros((1, self.__xsize))    
        

    

        
                
class DataAnalysis:
    """class used to analyse data generated by the Ballistic Deposition Class"""
    
    def __init__(self):
        analysis_array1=np.array([])
        analysis_array2=np.array([])
        analysis_array3=np.array([])
        analysis_array4=np.array([])
        self.analysis_array1=analysis_array1
        self.analysis_array2=analysis_array2
        self.analysis_array3=analysis_array3
        self.analysis_array4=analysis_array4
        
    def add_data(self, data, target_array):
        """filling data into separate roughness array and creating the matching time array; need to enter numpy array as the parameter"""
        for i in np.arange(0, data.size):
            target_array=np.append(target_array, data[i])
        return target_array
        
    def standard_deviations(self, errors_array):
        """works out the standard deviations for each set of data values stored in a 2D array"""
        x=np.array([])
        for i in np.arange(0, len(errors_array),1):
            x=np.append(x, np.std(errors_array[i]))
        return x
                  
    def roughness_dynamics(self, other, tracker, initial_power, data_points):#generates a series of roughness values for a series of matrices
        """iterates the BD forward in time, depositing n particles for each of the iterations; takes instance of the BallisticDeposition class"""
        
        x=np.array([])
       
        m=initial_power+1
        while m<=data_points+initial_power:            
            other.deposit_particles(2**m)        
            tracker.update(data_point_number=m-initial_power) 
            x=np.append(x, other.roughness()) #appending the roughnesses of system after each set of 2**m particles have been deposited
            tracker.display(other)
            m = m+1
            
        
        
        return x

    def create_time_array(self, initial_power, data_points):
        """creating the number of data points required; equally spaced on a log-log plot"""
        t=np.array([])
        m=initial_power+1
        y=0
        while m<=data_points+initial_power:           
            y=y+2**m
            t=np.append(t, y)
            m = m+1
        return t
        
        
    def roughness_dynamics_average(self, other, tracker, initial_power, data_points, simulations):
        """repeats same dynamic process for same system size for a specified number of times"""
        ###########NEED TO ADJUST CODE HERE TO EXTRACT DATA FOR ERROR BARS#############################~~~~~~~~~~~~~~~~~~
        x=np.zeros((data_points))
        z=np.zeros((data_points,simulations))
        
        for i in np.arange(0,simulations, 1):
            tracker.update(simulation_number=i+1)
            other.reset_system()
            y=self.roughness_dynamics(other, tracker, initial_power, data_points)
            x=x+y
            for j in np.arange(0,data_points,1):
                z[j][i]=y[j]
        
        x=x/simulations 
        t=self.create_time_array(initial_power, data_points)
        z=self.standard_deviations(z)
        upper_error= x+z
        lower_error= x-z
        return x, t, upper_error, lower_error


    def log_log_origin(self, initial_power, data_points, simulations, L_min, system_sizes):
        start = np.datetime64(datetime.datetime.now())
        other=BallisticDeposition(L_min)
        tracker=IterationTracker(number_of_system_sizes=system_sizes, total_data_points=data_points, total_simulations=simulations)        
        m=0
        while m<system_sizes:
            x, t, upper_error, lower_error= self.roughness_dynamics_average(other, tracker, initial_power, data_points, simulations)
            log_t=np.log(t)
            log_w=np.log(x)
            log_upper=np.log(upper_error)
            log_lower=np.log(lower_error)
            print log_w, log_upper, log_lower
            np.savetxt('%g.txt' % other.size_of_system(), np.transpose([log_t,log_w]))
            m=m+1
            other.reset_system(L_min+m*500) #increasing system by 500 each time
        end = np.datetime64(datetime.datetime.now())
        
        print start, end

############### DO NOT NEED BELOW METHOD AS ALL DATA NOW ANALYSED IN ORIGIN################################
  
    def log_log_line_plot(self, other, x_array, y_array, line_of_best_fit=None):
        """plots the roughness array against the time array stored using add_data()"""

        log_t=np.log(x_array)
        log_w=np.log(y_array)
        m, b = np.polyfit(log_t, log_w, 1)
        
        fig = plt.figure()
        fig.suptitle('Log-log Plot of Roughness Against Time', fontsize=14, fontweight='bold')
        ax = fig.add_subplot(111)
        #ax.set_title('axes title')

        ax.set_xlabel('log(t)')
        ax.set_ylabel('log(w)')
        ax.plot(log_t, log_w, 'r+')
        if line_of_best_fit == True:
            
            ax.plot(log_t, m*log_t + b, '-')
            ax.text(0.1,0.9, r'$\beta=$%g' % (m) , style='italic', horizontalalignment='left',verticalalignment='top', transform=ax.transAxes ) 
        ax.text(0.1,0.85, 'Particles Deposited=%g'  % (other.number_of_deposited_particles())  , style='italic', horizontalalignment='left',verticalalignment='top', transform=ax.transAxes ) #position of test and the test itself
        ax.text(0.1,0.8, 'System Size=%g'  % (other.size_of_system())  , style='italic', horizontalalignment='left',verticalalignment='top', transform=ax.transAxes )
        #plt.axis([40, 160, 0, 0.03])
        plt.grid(True)
        plt.show()
        
        return None
####################################################################################################################                
    
class IterationTracker:
    """class to track all the relevant stats during the simulation process"""

    def __init__(self, number_of_system_sizes=None, total_data_points=None, total_simulations=None):        
         self.__number_of_system_sizes=number_of_system_sizes
         self.__total_data_points=total_data_points
         self.__total_simulations=total_simulations
         self.__data_point_number=0
         self.__simulation_number=0
         
    def update(self, data_point_number=None, simulation_number=None):
        if data_point_number!=None:
            self.__data_point_number=data_point_number
        if simulation_number!=None:
            self.__simulation_number=simulation_number 
        
    def display(self, other):        
        print "%s %g, %s %g %s %g, %s %g %s %g" % ("system size =", other.size_of_system(), "simulation number", self.__simulation_number, "out of", self.__total_simulations, "data point",self.__data_point_number, "out of", self.__total_data_points )      
         
        
    

        
        
        
    
            
        